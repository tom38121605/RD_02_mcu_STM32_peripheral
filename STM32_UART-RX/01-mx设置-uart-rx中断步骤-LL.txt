

MCU: F030CCT6   (其他mcu可通用)

一. 在 LL库中添加 uart rx中断步骤：   

1. 建立工程     （4个地方）                            
   。双击打开mx
   。选择 start my project from mcu
   。输入mcu型号： STM32F030CCT6
   。点击start project
   

2. 设置时钟为HSI的48M     （1个地方）         

3. 设置 uart rx，如下：    

    。在引脚图上，把PA10设置为RX
    。mode： Asynchronous
    。Baud Rate： 1M

    。GPIO mode：          altemate Function push pull  (默认)
    。pull:                        no pull
    。Max output speed:  high
    。Fast mode：           disable      (好像都可以)  
    。user lable：            UART_RX
    
    。USART1 interrupt：  勾选         //  uart接收中断用  

5. 设置project，如下：  （6个地方）

    。设置工程目录： 原有的不变
    。设置工程名称： 原有的不变
    。设置IDE: MDK-ARM

    。勾选 copy only the necessary library files                            //原有的不变
    。勾选 Generate peripheral initialiation as a pair of 'c/h"files   //原有的不变

    。新加的UART1选择LL库


6. 保存mx，点击generate code，生成kel工程， ok      （1个地方）


二.  在keil 工程中， 添加代码，

   1. 在uart.c中， 添加

         void MX_USART1_UART_Init(void)
         {
            。。。。。。

           /* USER CODE BEGIN USART1_Init 2 */

            //LL_USART_ClearFlag_ORE(USART1);
            //LL_USART_ClearFlag_NE(USART1);
            //LL_USART_ClearFlag_PE(USART1);
            //LL_USART_ClearFlag_FE(USART1);

            LL_USART_EnableIT_RXNE(USART1);
            //LL_USART_EnableIT_ERROR(USART1); 
           
           /* USER CODE END USART1_Init 2 */

         }		


2. 在main.h中添加

         //--- uart ---
         #define CMDHEADER1 0xAA 
         #define CMDHEADER2 0x55 

         //--- uart rx ---
         #define PACKAGELEN  64  
         #define TXDATALEN  34   
         #define RXDATALEN  (PACKAGELEN+6) 

        uint8_t get_checksum_8(uint8_t *ival, uint32_t inum);

         extern volatile uint8_t flg_rx;
         extern volatile uint8_t irxdata[RXDATALEN+2];
         extern volatile uint8_t irxdata2[RXDATALEN+2];
         extern volatile uint32_t irxcount;
         extern volatile uint32_t irxcount2;


  3. 在stm32c0xx_it.c中 添加

       #include "string.h"      // memcpy

       volatile uint8_t flg_rx=0;
       volatile uint8_t irxdata[RXDATALEN+2]={0};
       volatile uint8_t irxdata2[RXDATALEN+2]={0};
       volatile uint32_t irxcount = 0;
       volatile uint32_t irxcount2 = 0;


       void USART1_IRQHandler(void)
       {
            /* USER CODE BEGIN USART1_IRQn 0 */

            static uint8_t flg_rxstart1 =0;
            static uint8_t flg_rxstart2 =0; 
            static uint8_t flg_rxstart3 =0; 
            static uint8_t ilen =0; 

            uint8_t cuartbyte=0;

            if (LL_USART_IsActiveFlag_RXNE(USART1) && LL_USART_IsEnabledIT_RXNE(USART1)) 
            {   
               //USART1->ISR &= ~(USART_ISR_RXNE_RXFNE);  //auto cleared by readed
               
               cuartbyte = (uint8_t)(READ_BIT(USART1->RDR, USART_RDR_RDR) & 0xFFU); 

               if( (flg_rxstart1==0) && ( cuartbyte !=CMDHEADER2) )   
                  return;      
                  
               if( (flg_rxstart1==0) && ( cuartbyte ==CMDHEADER2) )   
               {     
                  flg_rxstart1=1; 
                  irxdata[irxcount++]=cuartbyte;
                  return;
               }     

               if( (flg_rxstart2==0) && (flg_rxstart1==1) && ( cuartbyte !=CMDHEADER1) )  
               {         
                  flg_rxstart1=0;
                  irxcount=0;
                  return;
               }			
               if( (flg_rxstart2==0) && (flg_rxstart1==1) && ( cuartbyte ==CMDHEADER1) )   
               {         
                  flg_rxstart2=1;   
                  irxdata[irxcount++]=cuartbyte;
                  return;
               }
               
               if( (flg_rxstart2==1) && (flg_rxstart3==0) )  
               {   
                  ilen=cuartbyte; 
                  irxdata[irxcount++]=cuartbyte;
                  flg_rxstart3=1;
                 
                  return;
               }        
               
               if( flg_rxstart3==1)   
               {        
                  irxdata[irxcount++]=cuartbyte;

                  if(irxcount>=(ilen+3))
                  {
                     memcpy((void *)irxdata2,(void *)irxdata,irxcount);
                     irxcount2=irxcount;
                     flg_rx1=1;

                     irxcount=0;
                     ilen=0;
                     flg_rxstart1=0;
                     flg_rxstart2=0;		
                     flg_rxstart3=0;		            
                  }                 
               }
            } 
            else
            {
               
               //__IO uint32_t iregval;
               //iregval = LL_USART_ReadReg(USART1, ISR);

               //if (iregval & LL_USART_ISR_NE)  //2
               //   LL_USART_ClearFlag_NE(USART1);
               //else if (iregval & LL_USART_ISR_PE)  //0
               //   LL_USART_ClearFlag_PE(USART1);
               //else if (iregval & LL_USART_ISR_ORE)  //3
               //   LL_USART_ClearFlag_ORE(USART1);
               //else if (iregval & LL_USART_ISR_FE)  //1
               //   LL_USART_ClearFlag_FE(USART1);

               //LL_USART_ClearFlag_RTO(USART1);  //11
               //LL_USART_ClearFlag_UDR(USART1);;  //13
               
            }   

            /* USER CODE END USART1_IRQn 0 */
            /* USER CODE BEGIN USART1_IRQn 1 */

            /* USER CODE END USART1_IRQn 1 */
       }

4. 在main.c中添加

         uint8_t get_checksum_8(uint8_t *ival, uint32_t inum)
         {
            uint32_t i =0;
            uint8_t iret =0;
            uint16_t isum =0;

            for (i=0; i<inum; i++)
            {
               isum += ival[i]; 
            }

            iret = (uint8_t)(isum & 0xff);

            return iret;
         }


       while

         //uart rx
         if (flg_rx==1)
         {
            flg_rx=0;
            uartsendstr( (uint8_t*)"rx in\r\n" );
            
            //islaveaddrin=irxdata2[4];

            //checksum
            uint8_t ichecksum=0;
            ichecksum = get_checksum_8((uint8_t *)irxdata2,irxcount2-1);

            if(ichecksum == irxdata2[irxcount2-1])  
               ;//if(islaveaddrin==LOCALSLAVEADDR)            
                  //dowithuart();     
         }  


