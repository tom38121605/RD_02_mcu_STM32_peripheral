

MCU: F030CCT6   (其他mcu可通用)

一. 在 LL库中添加 uart rx中断步骤：   

  （同之前的rx）


二.  在keil 工程中， 添加代码，

   1. 在uart.c中， 添加

         void MX_USART1_UART_Init(void)
         {
            。。。。。。

            /* USER CODE BEGIN USART1_Init 2 */

            //LL_USART_ClearFlag_ORE(USART1);
            //LL_USART_ClearFlag_NE(USART1);
            //LL_USART_ClearFlag_PE(USART1);
            //LL_USART_ClearFlag_FE(USART1);

            LL_USART_EnableIT_RXNE(USART1);
            //LL_USART_EnableIT_ERROR(USART1); 

            /* USER CODE END USART1_Init 2 */

         }



2. 在main.h中添加

         #include "string.h"        //  memcpy


         //--- uart ---
         #define CMDHEADER1 0xAA 
         #define CMDHEADER2 0x55 

         //--- uart rx ---
         #define PACKAGELEN  64  
         #define TXDATALEN  34   
         #define RXDATALEN  (PACKAGELEN+6) 

          uint8_t get_checksum_8(uint8_t *ival, uint32_t inum)； 
         void uart1_rx_callback(void);


  3. 在stm32c0xx_it.c中 添加

         void USART1_IRQHandler(void)
         {
               /* USER CODE BEGIN USART1_IRQn 0 */

               uart1_rx_callback();                                    //--add


               /* USER CODE END USART1_IRQn 0 */
               /* USER CODE BEGIN USART1_IRQn 1 */

               /* USER CODE END USART1_IRQn 1 */
         }


4. 在main.c中添加

         volatile uint8_t flg_rx=0;
         volatile uint8_t irxdata[RXDATALEN+2]={0};
         volatile uint8_t irxdata2[RXDATALEN+2]={0};
         volatile uint32_t irxcount = 0;
         volatile uint32_t irxcount2 = 0;

         uint8_t get_checksum_8(uint8_t *ival, uint32_t inum)
         {
            uint32_t i =0;
            uint8_t iret =0;
            uint16_t isum =0;

            for (i=0; i<inum; i++)
            {
               isum += ival[i]; 
            }

            iret = (uint8_t)(isum & 0xff);
            return iret;
         }


         void uart1_rx_callback(void) 
         {
               static uint8_t flg_rxstart1 =0;
               static uint8_t flg_rxstart2 =0; 
               static uint8_t flg_rxstart3 =0; 
               static uint8_t ilen =0; 

               uint8_t cuartbyte=0;

               if (LL_USART_IsActiveFlag_RXNE(USART1) && LL_USART_IsEnabledIT_RXNE(USART1)) 
               {   
                  //USART1->ISR &= ~(USART_ISR_RXNE_RXFNE);  //auto cleared by readed
                  
                  cuartbyte = (uint8_t)(READ_BIT(USART1->RDR, USART_RDR_RDR) & 0xFFU); 

                  if( (flg_rxstart1==0) && ( cuartbyte !=CMDHEADER2) )   
                     return;      
                     
                  if( (flg_rxstart1==0) && ( cuartbyte ==CMDHEADER2) )   
                  {     
                     flg_rxstart1=1; 
                     irxdata[irxcount++]=cuartbyte;
                     return;
                  }     

                  if( (flg_rxstart2==0) && (flg_rxstart1==1) && ( cuartbyte !=CMDHEADER1) )  
                  {         
                     flg_rxstart1=0;
                     irxcount=0;
                     return;
                  }			
                  if( (flg_rxstart2==0) && (flg_rxstart1==1) && ( cuartbyte ==CMDHEADER1) )   
                  {         
                     flg_rxstart2=1;   
                     irxdata[irxcount++]=cuartbyte;
                     return;
                  }
                  
                  if( (flg_rxstart2==1) && (flg_rxstart3==0) )  
                  {   
                     ilen=cuartbyte; 
                     irxdata[irxcount++]=cuartbyte;
                     flg_rxstart3=1;
                    
                     return;
                  }        
                  
                  if( flg_rxstart3==1)   
                  {        
                     irxdata[irxcount++]=cuartbyte;

                     if(irxcount>=(ilen+3))
                     {
                        memcpy((void *)irxdata2,(void *)irxdata,irxcount);
                        irxcount2=irxcount;
                        flg_rx1=1;

                        irxcount=0;
                        ilen=0;
                        flg_rxstart1=0;
                        flg_rxstart2=0;		
                        flg_rxstart3=0;		            
                     }                 
                  }
               } 
               else
               {
                  
                  //__IO uint32_t iregval;
                  //iregval = LL_USART_ReadReg(USART1, ISR);

                  //if (iregval & LL_USART_ISR_NE)  //2
                  //   LL_USART_ClearFlag_NE(USART1);
                  //else if (iregval & LL_USART_ISR_PE)  //0
                  //   LL_USART_ClearFlag_PE(USART1);
                  //else if (iregval & LL_USART_ISR_ORE)  //3
                  //   LL_USART_ClearFlag_ORE(USART1);
                  //else if (iregval & LL_USART_ISR_FE)  //1
                  //   LL_USART_ClearFlag_FE(USART1);

                  //LL_USART_ClearFlag_RTO(USART1);  //11
                  //LL_USART_ClearFlag_UDR(USART1);;  //13
                  
               }   
         }


    main()
         while

            //uart rx
            if (flg_rx==1)
            {
               flg_rx=0;
               uartsendstr( (uint8_t*)"rx in\r\n" );
               
               //islaveaddrin=irxdata2[4];

               //checksum
               uint8_t ichecksum=0;
               ichecksum = get_checksum_8((uint8_t *)irxdata2,irxcount2-1);

               if(ichecksum == irxdata2[irxcount2-1])  
                  ;//if(islaveaddrin==LOCALSLAVEADDR)            
                     //dowithuart();     
            }  




